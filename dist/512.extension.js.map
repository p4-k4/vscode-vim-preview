{"version":3,"file":"512.extension.js","mappings":"2GAAA,MAAMA,EAAgBC,OAAO,iBACvBC,EAAeD,OAAO,gBAEtBE,EAAyB,IAAM,GAC/BC,EAAsB,CAACC,EAAQC,EAAOC,IAAQF,EAAOG,MAAMF,EAAOC,GAAKE,QAAQ,MAAO,KAEtFC,EAAY,CAACC,EAAYC,KAC9B,IAAIC,EAAQD,EAAgB,EACxBE,EAAiB,EAErB,KAA6B,OAAtBH,EAAWE,IACjBA,GAAS,EACTC,GAAkB,EAGnB,OAAOC,QAAQD,EAAiB,EAAE,EAGpB,SAASE,EAAkBL,GAAY,WAACM,GAAa,EAAI,eAAEC,GAAiB,GAAS,CAAC,GACpG,GAA0B,iBAAfP,EACV,MAAM,IAAIQ,UAAU,qEAAqER,OAG1F,MAAMS,EAAQH,EAAab,EAAsBD,EAEjD,IAAIkB,GAAiB,EACjBC,GAAkB,EAClBC,EAAS,EACTC,EAAS,GACTC,EAAS,GACTC,GAAc,EAElB,IAAK,IAAIb,EAAQ,EAAGA,EAAQF,EAAWgB,OAAQd,IAAS,CACvD,MAAMe,EAAmBjB,EAAWE,GAC9BgB,EAAgBlB,EAAWE,EAAQ,GAUzC,GARKS,GAAwC,MAArBM,GAEPlB,EAAUC,EAAYE,KAErCQ,GAAkBA,IAIhBA,EAIJ,GAAKC,GAAmBM,EAAmBC,IAAkB,KAMtD,IAAIP,IAAoBtB,GAAiB4B,EAAmBC,IAAkB,OAAQ,CAE5FhB,IACAS,GAAkB,EAClBE,GAAUJ,EAAMT,EAAYY,EAAQV,GACpCU,EAASV,EACT,QACD,CAAO,GAAIS,IAAoBtB,GAAsC,OAArB4B,EAE/CN,GAAkB,EAClBE,GAAUJ,EAAMT,EAAYY,EAAQV,GACpCU,EAASV,MACH,KAAKS,GAAmBM,EAAmBC,IAAkB,KAAM,CAEzEL,GAAUb,EAAWH,MAAMe,EAAQV,GACnCU,EAASV,EACTS,EAAkBpB,EAClBW,IACA,QACD,CAAO,GAAIS,IAAoBpB,GAAgB0B,EAAmBC,IAAkB,KAAM,CAEzFhB,IACAS,GAAkB,EAClBE,GAAUJ,EAAMT,EAAYY,EAAQV,EAAQ,GAC5CU,EAASV,EAAQ,EACjB,QACD,CAAWK,IAAmBI,KACT,IAAhBI,EACsB,MAArBE,GAAiD,MAArBA,GAE/BJ,GAAUb,EAAWH,MAAMe,EAAQV,GACnCY,GAAUL,EAAMI,EAAQ,EAAG,GAAKA,EAAOhB,MAAM,GAC7CgB,EAAS,GACTD,EAASV,EACTa,GAAc,GACiB,MAArBE,GAAiD,OAArBA,GAAkD,OAArBA,GAAkD,OAArBA,IAEhGJ,GAAUb,EAAWH,MAAMe,EAAQV,GACnCU,EAASV,EACTa,GAAc,GAEgB,MAArBE,IAEVH,GAAUD,EAASb,EAAWH,MAAMe,EAAQV,GAC5CW,EAAS,GACTD,EAASV,EACTa,EAAab,GAEf,OApDCW,GAAUb,EAAWH,MAAMe,EAAQV,GACnCU,EAASV,EACTS,EAAkBtB,EAClBa,GAkDF,CAEA,OAAOY,EAASD,GAAUF,EAAkBF,EAAMT,EAAWH,MAAMe,IAAWZ,EAAWH,MAAMe,GAChG,C","sources":["webpack://vscode-vim-preview/./node_modules/strip-json-comments/index.js"],"sourcesContent":["const singleComment = Symbol('singleComment');\nconst multiComment = Symbol('multiComment');\n\nconst stripWithoutWhitespace = () => '';\nconst stripWithWhitespace = (string, start, end) => string.slice(start, end).replace(/\\S/g, ' ');\n\nconst isEscaped = (jsonString, quotePosition) => {\n\tlet index = quotePosition - 1;\n\tlet backslashCount = 0;\n\n\twhile (jsonString[index] === '\\\\') {\n\t\tindex -= 1;\n\t\tbackslashCount += 1;\n\t}\n\n\treturn Boolean(backslashCount % 2);\n};\n\nexport default function stripJsonComments(jsonString, {whitespace = true, trailingCommas = false} = {}) {\n\tif (typeof jsonString !== 'string') {\n\t\tthrow new TypeError(`Expected argument \\`jsonString\\` to be a \\`string\\`, got \\`${typeof jsonString}\\``);\n\t}\n\n\tconst strip = whitespace ? stripWithWhitespace : stripWithoutWhitespace;\n\n\tlet isInsideString = false;\n\tlet isInsideComment = false;\n\tlet offset = 0;\n\tlet buffer = '';\n\tlet result = '';\n\tlet commaIndex = -1;\n\n\tfor (let index = 0; index < jsonString.length; index++) {\n\t\tconst currentCharacter = jsonString[index];\n\t\tconst nextCharacter = jsonString[index + 1];\n\n\t\tif (!isInsideComment && currentCharacter === '\"') {\n\t\t\t// Enter or exit string\n\t\t\tconst escaped = isEscaped(jsonString, index);\n\t\t\tif (!escaped) {\n\t\t\t\tisInsideString = !isInsideString;\n\t\t\t}\n\t\t}\n\n\t\tif (isInsideString) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!isInsideComment && currentCharacter + nextCharacter === '//') {\n\t\t\t// Enter single-line comment\n\t\t\tbuffer += jsonString.slice(offset, index);\n\t\t\toffset = index;\n\t\t\tisInsideComment = singleComment;\n\t\t\tindex++;\n\t\t} else if (isInsideComment === singleComment && currentCharacter + nextCharacter === '\\r\\n') {\n\t\t\t// Exit single-line comment via \\r\\n\n\t\t\tindex++;\n\t\t\tisInsideComment = false;\n\t\t\tbuffer += strip(jsonString, offset, index);\n\t\t\toffset = index;\n\t\t\tcontinue;\n\t\t} else if (isInsideComment === singleComment && currentCharacter === '\\n') {\n\t\t\t// Exit single-line comment via \\n\n\t\t\tisInsideComment = false;\n\t\t\tbuffer += strip(jsonString, offset, index);\n\t\t\toffset = index;\n\t\t} else if (!isInsideComment && currentCharacter + nextCharacter === '/*') {\n\t\t\t// Enter multiline comment\n\t\t\tbuffer += jsonString.slice(offset, index);\n\t\t\toffset = index;\n\t\t\tisInsideComment = multiComment;\n\t\t\tindex++;\n\t\t\tcontinue;\n\t\t} else if (isInsideComment === multiComment && currentCharacter + nextCharacter === '*/') {\n\t\t\t// Exit multiline comment\n\t\t\tindex++;\n\t\t\tisInsideComment = false;\n\t\t\tbuffer += strip(jsonString, offset, index + 1);\n\t\t\toffset = index + 1;\n\t\t\tcontinue;\n\t\t} else if (trailingCommas && !isInsideComment) {\n\t\t\tif (commaIndex !== -1) {\n\t\t\t\tif (currentCharacter === '}' || currentCharacter === ']') {\n\t\t\t\t\t// Strip trailing comma\n\t\t\t\t\tbuffer += jsonString.slice(offset, index);\n\t\t\t\t\tresult += strip(buffer, 0, 1) + buffer.slice(1);\n\t\t\t\t\tbuffer = '';\n\t\t\t\t\toffset = index;\n\t\t\t\t\tcommaIndex = -1;\n\t\t\t\t} else if (currentCharacter !== ' ' && currentCharacter !== '\\t' && currentCharacter !== '\\r' && currentCharacter !== '\\n') {\n\t\t\t\t\t// Hit non-whitespace following a comma; comma is not trailing\n\t\t\t\t\tbuffer += jsonString.slice(offset, index);\n\t\t\t\t\toffset = index;\n\t\t\t\t\tcommaIndex = -1;\n\t\t\t\t}\n\t\t\t} else if (currentCharacter === ',') {\n\t\t\t\t// Flush buffer prior to this point, and save new comma index\n\t\t\t\tresult += buffer + jsonString.slice(offset, index);\n\t\t\t\tbuffer = '';\n\t\t\t\toffset = index;\n\t\t\t\tcommaIndex = index;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result + buffer + (isInsideComment ? strip(jsonString.slice(offset)) : jsonString.slice(offset));\n}\n"],"names":["singleComment","Symbol","multiComment","stripWithoutWhitespace","stripWithWhitespace","string","start","end","slice","replace","isEscaped","jsonString","quotePosition","index","backslashCount","Boolean","stripJsonComments","whitespace","trailingCommas","TypeError","strip","isInsideString","isInsideComment","offset","buffer","result","commaIndex","length","currentCharacter","nextCharacter"],"sourceRoot":""}